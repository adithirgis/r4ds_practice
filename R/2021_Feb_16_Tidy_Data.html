<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R4DS Book Club</title>
    <meta charset="utf-8" />
    <meta name="author" content="Adithi R. Upadhya, ILK Labs" />
    <meta name="date" content="2021-02-15" />
    <link href="2021_Feb_16_Tidy_Data_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="2021_Feb_16_Tidy_Data_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# R4DS Book Club
## Chapter 12 - Tidy Data
### Adithi R. Upadhya, ILK Labs
### 2021-02-15

---


## Organise your Data in R 


```r
library(tidyverse)
```

```
## -- Attaching packages -------------------------------------- tidyverse 1.3.0 --
```

```
## v ggplot2 3.3.2     v purrr   0.3.4
## v tibble  3.0.3     v dplyr   1.0.0
## v tidyr   1.1.0     v stringr 1.4.0
## v readr   1.3.1     v forcats 0.5.0
```

```
## Warning: package 'ggplot2' was built under R version 4.0.2
```

```
## Warning: package 'tibble' was built under R version 4.0.2
```

```
## Warning: package 'tidyr' was built under R version 4.0.2
```

```
## Warning: package 'dplyr' was built under R version 4.0.2
```

```
## -- Conflicts ----------------------------------------- tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()
```


---
## Tidy the data!

How to make a dataset tidy:

 1. Each variable must have its own column.
 2. Each observation must have its own row.
 3. Each value must have its own cell.
 
 
![](https://raw.githubusercontent.com/hadley/r4ds/master/images/tidy-1.png)&lt;!-- --&gt;

---

## Practical Instructions

- Put each dataset in a tibble.
- Put each variable in a column.

### Advantages

- Ease of management 
- Maximum utilisation of R's super powers!


---
## Untidy data example 1

### More than one variable per column


```r
table3
```

```
## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583
```

---

### 12.2.1 - Q1

Using prose, describe how the variables and observations are organised in each of the sample tables.
    
* **table 1**: Example of tidy dataset - has each variable in a column, each observation in a row and each cell/ unit has only one value. The data shows the number of cases and population in differents countries by year.


```r
table1
```

```
## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583
```

---
    
* **table 2**: Example of untidy dataset - has a pair of rows showing similar values. For each country and year the case and population is stacked one below other. 


```r
table2
```

```
## # A tibble: 12 x 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583
```

---
    
* **table 3**: Example of untidy dataset - has each row which contains country and year but the thrid column rate is represented as a combination of two columns - cases/population. Though this number is useful but the representation is confusing. 


```r
table3
```

```
## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583
```

---

* **table 4a** and **table 4b**: Example of untidy and long data set, has each row representing either country and population for two years or countryand cases, with the different years as column names. 

```r
table4a
```

```
## # A tibble: 3 x 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766
```


```r
table4b
```

```
## # A tibble: 3 x 3
##   country         `1999`     `2000`
## * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan   19987071   20595360
## 2 Brazil       172006362  174504898
## 3 China       1272915272 1280428583
```

---

### 12.2.1 - Q2

Compute the `rate` for `table2`, and `table4a` + `table4b`. 
    You will need to perform four operations:

  1.  Extract the number of TB cases per country per year.
  2.  Extract the matching population per country per year.
  3.  Divide cases by population, and multiply by 10000.
  4.  Store back in the appropriate place.
      
Which representation is easiest to work with? Which is hardest? Why?

---

#### `table2` 


```r
cases &lt;- table2 %&gt;% 
  filter(type == "cases") %&gt;%
  select(everything(), - type)
pop &lt;- table2 %&gt;% 
  filter(type == "population") %&gt;%
  select(everything(), - type)
rate_table &lt;- cases %&gt;% 
  inner_join(pop, by = c("country", "year"),
                         suffix = c("_cases", "_pop")) %&gt;%
  mutate(rate = (count_cases / count_pop) * 10000, 
         type = "rate") %&gt;%
  select(country, year, type, count = rate) 
rate_table %&gt;% 
  bind_rows(table2) %&gt;%
  arrange(country, year, type)
```

```
## # A tibble: 18 x 4
##    country      year type         count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;
##  1 Afghanistan  1999 cases      7.45e+2
##  2 Afghanistan  1999 population 2.00e+7
##  3 Afghanistan  1999 rate       3.73e-1
##  4 Afghanistan  2000 cases      2.67e+3
##  5 Afghanistan  2000 population 2.06e+7
##  6 Afghanistan  2000 rate       1.29e+0
##  7 Brazil       1999 cases      3.77e+4
##  8 Brazil       1999 population 1.72e+8
##  9 Brazil       1999 rate       2.19e+0
## 10 Brazil       2000 cases      8.05e+4
## 11 Brazil       2000 population 1.75e+8
## 12 Brazil       2000 rate       4.61e+0
## 13 China        1999 cases      2.12e+5
## 14 China        1999 population 1.27e+9
## 15 China        1999 rate       1.67e+0
## 16 China        2000 cases      2.14e+5
## 17 China        2000 population 1.28e+9
## 18 China        2000 rate       1.67e+0
```

---

#### `table4a` and `table4b`
    

```r
table4c &lt;- data.frame( country = table4b$country,
    year_99 = table4a["1999"] / table4b["1999"] * 10000,
    year_00 = table4a["2000"] / table4b["2000"] * 10000)

names(table4c) &lt;- c("country", "1999", "2000")

table4c
```

```
##       country     1999     2000
## 1 Afghanistan 0.372741 1.294466
## 2      Brazil 2.193930 4.612363
## 3       China 1.667495 1.669488
```


---

### 12.2.1 - Q3

Recreate the plot showing change in cases over time using `table2` instead of `table1`. What do you need to do first?


```r
library(ggplot2)
table2_plot &lt;- table2 %&gt;% 
  filter(type == "cases") 
  
plot &lt;- ggplot(table2_plot, aes(year, count)) +
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))
plot
```

![](2021_Feb_16_Tidy_Data_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;

---

## Pivoting

### Most data is untidy - 

- Most people aren’t familiar with the principles of tidy data, and it’s hard to derive them yourself unless you spend a lot of time working with data.

- Data is often organised to facilitate some use other than analysis. For example, data is often organised to make entry as easy as possible.

---

### Two common problems - 

* one variable might be spread across multiple columns, 
* one observation might be scattered across multiple rows.


---

In cases where column names are not names of variables but values of a variable, use `pivot_longer()`.

![](https://d33wubrfki0l68.cloudfront.net/3aea19108d39606bbe49981acda07696c0c7fcd8/2de65/images/tidy-9.png)&lt;!-- --&gt;

Pivoted columns (`1999` and `2000`) are dropped, their names are placed in the new `year` column, and values in the new `count` column.

---

In cases where an observation is scattered across multiple rows, use `pivot_wider()`.

![](https://d33wubrfki0l68.cloudfront.net/8350f0dda414629b9d6c354f87acf5c5f722be43/bcb84/images/tidy-8.png)&lt;!-- --&gt;

---

### 12.3.3- Q1

Why are pivot_longer() and pivot_wider() not perfectly symmetrical?
Carefully consider the following example:

pivot_longer() has a names_ptypes argument, e.g.  names_ptypes = list(year = double()). What does it do?


```r
stocks &lt;- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks %&gt;% 
  pivot_wider(names_from = year, values_from = return) %&gt;% 
  pivot_longer(`2015`:`2016`, names_to = "year", values_to = "return")
```

```
## # A tibble: 4 x 3
##    half year  return
##   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
## 1     1 2015    1.88
## 2     1 2016    0.92
## 3     2 2015    0.59
## 4     2 2016    0.17
```

The `pivot_longer()` call turns column names into character by default. Can override this using the `names_ptype` argument.



```r
stocks %&gt;%
  pivot_wider(names_from = year, values_from = return)%&gt;%
  pivot_longer(`2015`:`2016`, names_to = "year", values_to = "return",
               names_transform = list(year = as.numeric))
```

```
## # A tibble: 4 x 3
##    half  year return
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     1  2015   1.88
## 2     1  2016   0.92
## 3     2  2015   0.59
## 4     2  2016   0.17
```

---

### 12.3.3- Q2

Why does this code fail?
 

```r
# table4a %&gt;% 
#   pivot_longer(c(1999, 2000), names_to = "year", values_to = "cases")
#&gt; Error: Can't subset columns that don't exist.
#&gt; ✖ Locations 1999 and 2000 don't exist.
#&gt; ℹ There are only 3 columns.
```

`1999` and `2000` are not the correct way to represent the column name, they need to be surrounded by backticks / "" or else R will try to select that number column.


```r
table4a %&gt;% 
  pivot_longer(c(`1999`, `2000`), names_to = "year",
               values_to = "cases")
```

```
## # A tibble: 6 x 3
##   country     year   cases
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
## 1 Afghanistan 1999     745
## 2 Afghanistan 2000    2666
## 3 Brazil      1999   37737
## 4 Brazil      2000   80488
## 5 China       1999  212258
## 6 China       2000  213766
```

---

### 12.3.3- Q3

What would happen if you widen this table? Why? How could you add a new column to uniquely identify each value?



```r
people &lt;- tribble(
  ~name,             ~names,  ~values,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Phillip Woods",   "age",       50,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156)

people %&gt;% 
  group_by(name, names) %&gt;%
  mutate(id = row_number()) %&gt;%
  ungroup() %&gt;%
  pivot_wider(names_from = "name", values_from = "values")
```

```
## # A tibble: 3 x 4
##   names     id `Phillip Woods` `Jessica Cordero`
##   &lt;chr&gt;  &lt;int&gt;           &lt;dbl&gt;             &lt;dbl&gt;
## 1 age        1              45                37
## 2 height     1             186               156
## 3 age        2              50                NA
```

---

### 12.3.3- Q4

Tidy the simple tibble below. Do you need to make it wider or longer? What are the variables?


```r
preg &lt;- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)

preg_tidy &lt;- preg %&gt;% 
  pivot_longer(c(male, female), names_to = "gender", values_to = "count")

preg_tidy
```

```
## # A tibble: 4 x 3
##   pregnant gender count
##   &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt;
## 1 yes      male      NA
## 2 yes      female    10
## 3 no       male      20
## 4 no       female    12
```

---

## Separate

`separate()` pulls apart one column into multiple columns, by splitting wherever a separator character appears. By default, it separates at any non-alphanumeric character, a specific character can also be passed in the `sep` argument or a vector of integers can also be passed to separate a column at specific positions.

By default, the column type is preserved, but this can be controlled using `convert = TRUE`. 

![](https://d33wubrfki0l68.cloudfront.net/f6fca537e77896868fedcd85d9d01031930d76c9/637d9/images/tidy-17.png)&lt;!-- --&gt;

---

## Unite

`unite()` is the inverse of `separate()`: it combines multiple columns into a single column, using an optional separator between the values from different columns (default is `_`).

![](https://d33wubrfki0l68.cloudfront.net/3d98d3ba019fed3f9ee328284568d4508e479ef8/0b3e6/images/tidy-18.png)&lt;!-- --&gt;

---

### 12.4.3- Q1

What do the `extra` and `fill` arguments do in `separate()`? Experiment with the various options for the following two toy datasets.


```r
# tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %&gt;%
#   separate(x, c("one", "two", "three"))
## Expected 3 pieces. Additional pieces 
## discarded in 1 rows [2].

# tibble(x = c("a,b,c", "d,e", "f,g,i")) %&gt;%
#  separate(x, c("one", "two", "three"))
## Expected 3 pieces. Missing pieces filled 
## with `NA` in 1 rows [2].
```

---

### Examples

The `extra` and `fill` arguments help in dealing with extra / more or fewer columns than expected based on the new column names. `extra &lt;- c('warn', 'drop', 'merge')`; `fill &lt;- c('warn', 'left', 'right')`.


```r
tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %&gt;%
  separate(x, c("one", "two", "three"), extra = "merge")
```

```
## # A tibble: 3 x 3
##   one   two   three
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 a     b     c    
## 2 d     e     f,g  
## 3 h     i     j
```


```r
tibble(x = c("a,b,c", "d,e", "f,g,i")) %&gt;%
  separate(x, c("one", "two", "three"), fill = "left")
```

```
## # A tibble: 3 x 3
##   one   two   three
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 a     b     c    
## 2 &lt;NA&gt;  d     e    
## 3 f     g     i
```




---

### 12.4.3- Q2

Both `unite()` and `separate()` have a `remove` argument. What does it do? Why would you set it to FALSE?


```r
tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %&gt;%
  separate(x, c("one", "two", "three"), extra = "merge", remove = TRUE)
```

```
## # A tibble: 3 x 3
##   one   two   three
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 a     b     c    
## 2 d     e     f,g  
## 3 h     i     j
```

The `remove` argument removes the original column(s) used for uniting or separating. 

---
class: inverse

### 12.4.3- Q3

Compare and contrast `separate()` and `extract()`. Why are there three variations of separation (by position, by separator, and with groups), but only one unite?

- The function `separate()`, splits a column into multiple columns by separator, if the `sep` argument is a character vector, or by character positions, if `sep` is numeric.

- The function `extract()` uses a regular expression to specify groups in character vector and split that single character vector into multiple columns. This is more flexible than `separate()` because it does not require a common separator or specific column positions.

- In other words, with `extract()` and `separate()` only one column can be chosen, but there are many choices how to split that single column into different columns. With `unite()`, there are many choices as to which columns to include, but only one choice as to how to combine their contents into a single vector.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
